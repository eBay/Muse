# Shared Modules

Muse's shared modules mechanism allows a plugin to be built on some common shared modules which are provided by lib plugins. Usually you don't need to specify which modules should be shared but all modules used in lib plugins are shared by default. It is achieved by [Muse webpack plugin](https://github.com/ebay/muse/tree/main/workspace/packages/muse-webpack-plugin), while is heavily inspired by [webpack DLL plugin](https://webpack.js.org/plugins/dll-plugin/).

<img src={require("/img/muse-shared-modules.png").default} width="400" />

In this topic we will learn the details of the mechanism. 

:::note

It's unnecessary to deep dive into this to use Muse. Just if you are interested or you want implement the mechanism for other bundlers other than webpack.

:::

## Shared modules at runtime
The shared modules container is a central place that allows to register or require a module. At build time, the Muse webpack plugin generates code to register all modules in a lib plugins to the container. Then after the build bundle is loaded, all shared modules are registered. By default, it's exposed by the API `MUSE_GLOBAL.__shared__`. It has two methods:

### 1. register(modules, requireMethod)
It's used of register shared modules to the container. Muse doesn't modules, but just a manager who knows how to get a module. There are two paramenters:
- **modules**: it's a id/value mapping object. For example:
```js
{
  "axios@0.27.2/lib/axios.js": 1,
  "lodash@4.17.21/castArray.js": 1,
  ...
}
```

Every module has an `id` in format of `<package-name>@<version>/<path-to-the-module>`, we also call it Muse module id, by which it's able to resolve modules semanticly. It's also the webpack's module id generated by an internal Muse module id webpack plugin.

:::note
The magic value `1` means it's not used for now, so any value is acceptable. We use an object to pass module ids to the `register` method just because we think we may need more paramters in future.
:::

- **requireMethod**: the method to require the module. Muse doesn't care about the format of a shared module but just delegate the module provider about how to resolve a module. In webpack, we pass `__webpack_require__` as the parameter.

So, in every lib plugin's bundle result, there's code like below to register all shared modules:

```js
MUSE_GLOBAL.__shared__.register(__webpack_modules__, __webpack_require__);
```
### 2. require(museModuleId)
This method is used to get a shared module. By the Muse module id, we know all information the required module. So internally it's resolved by Muse first, if the exact id exists, then use it. Otherwise, find the closest version of the module then ask the module's require mehtod (provided when register) to get it. This mechanism allows you to upgrade a shared module without rebuilding all dependent plugins.

In the webpack plugin implementation, we define a external module to delegate all shared modules to real modules. For example, below is code fragment from the build result shows how the module `css-loader@6.7.1/dist/runtime/api.js` is required from the shared modules container.

```js
"muse-shared-modules":
/*!*************************************************!*\
  !*** external "MUSE_GLOBAL.__shared__.require" ***!
  \*************************************************/
((module) => {
  "use strict";
  module.exports = MUSE_GLOBAL.__shared__.require;
}),

"./node_modules/.pnpm/css-loader@6.7.1_webpack@5.73.0/node_modules/css-loader/dist/runtime/api.js":
/*!*******************************************************************************************************************************************!*\
  !*** delegated ./node_modules/.pnpm/css-loader@6.7.1_webpack@5.73.0/node_modules/css-loader/dist/runtime/api.js from muse-shared-modules ***!
  \*******************************************************************************************************************************************/
((module, __unused_webpack_exports, __webpack_require__) => {
  module.exports = (__webpack_require__(/*! muse-shared-modules */ "muse-shared-modules"))("css-loader@6.7.1/dist/runtime/api.js");
}),
```

## Shared modules at build time
While build a lib plugin, it generates a file named `lib-manifest.json` to tell which shared modules it provides. The content is like below, very similar with which of webpack DLL plugin:
```js
{
  "type": "lib",
  "content": {
    "@babel/runtime@7.18.6/helpers/esm/defineProperty.js": {
      "id": "@babel/runtime@7.18.6/helpers/esm/defineProperty.js",
      "buildMeta": {
        "exportsType": "namespace",
        "strictHarmonyModule": true
      },
      "exports": [
        "default"
      ]
    },
    "@babel/runtime@7.18.6/helpers/esm/extends.js": {
      "id": "@babel/runtime@7.18.6/helpers/esm/extends.js",
      "buildMeta": {
        "exportsType": "namespace",
        "strictHarmonyModule": true
      },
      "exports": [
        "default"
      ]
    },
    ...
  }
}
```

Then when build other plugins which has the lib plugin as a dependency, the Muse webpack plugin will read the manifest to know which modules should be delegated. For a shared module, it will generate code like below:

```js
"./node_modules/.pnpm/css-loader@6.7.1_webpack@5.73.0/node_modules/css-loader/dist/runtime/api.js":
/*!*******************************************************************************************************************************************!*\
  !*** delegated ./node_modules/.pnpm/css-loader@6.7.1_webpack@5.73.0/node_modules/css-loader/dist/runtime/api.js from muse-shared-modules ***!
  \*******************************************************************************************************************************************/
((module, __unused_webpack_exports, __webpack_require__) => {
  module.exports = (__webpack_require__(/*! muse-shared-modules */ "muse-shared-modules"))("css-loader@6.7.1/dist/runtime/api.js");
}),
```
## Check dependencies before deployment
Whenever you deploy a plugin to an app, it assumes all necessary shared modules (dependencies) already there. For example, if your plugin depends on a lib plugin named `some-lib-plugin`. Then normally it should have been deployed to the app so that your plugin could find shared modules at runtime.

:::note
Muse doesn't auto download depending lib plugins, that is, there aren't async shared modules. You need to ensure they are there.
:::

However, if your app consists of dozens of plugins, the dependency will become a bit complicated, it's sometimes not obvious if necessary plugins already be deployed. So, we have the mechanism to check it before deploy a plugin.

When build a lib or normal plugin, it will generate a file named `deps-manifest.json` which tells what shared modules should the plugin depends on and where they are from when build. The format is like below:

```js
{
  "content": {
    "@ebay/muse-lib-react@1.0.23": [
      "js-plugin@1.1.0/plugin.js",
      "react-router-dom@6.3.0/index.js",
      "react@18.2.0/jsx-dev-runtime.js",
      "css-loader@6.7.1/dist/runtime/sourceMaps.js",
      "css-loader@6.7.1/dist/runtime/api.js"
    ],
    "@ebay/muse-lib-antd@1.0.12": [
      "antd@4.20.7/es/index.js",
      "react-syntax-highlighter@15.5.0/dist/esm/index.js",
      "@ant-design/icons@4.7.0/es/index.js",
      "react-syntax-highlighter@15.5.0/dist/esm/styles/hljs/default-style.js"
    ]
  }
}
```

Then when deploy a plugin, there's enought information about if all shared modules already deployed to the app. You will receive an error if some shared modules are missing when you run `muse deploy` command.

:::note

We only need to guranteen the necessary shared modules are there but not plugins. Though in `deps-manifest.json` we have information which plugins the project depends on to do the build. It's actually just used to prompt user info like "You might forget to deploy plugin `some-lib-plugin` to the app?".

That means, you can provide shared modules from a different lib plugin other than the lib plugin used to build.

:::

Similarly, when you deploy a new version of lib plugin, it may have removed some shared modules, the deploy flow can also detect it and warn user that some shared modules are missing before deploy the change to the app.

## Exclude shared modules
When build a lib plugin, it assumes all modules used in the lib plugin are shared modules. But sometimes you don't want some modules to be shared, you can exclude them by:

```json
"muse": {
  "sharedLibs": {
    "exclude": ["some-package"]
  },
}
```

All packages will not be shared in `exclude` property.

## Ignore shared modules
By default it always use shared modules if possible (even version doesn't match) when build a plugin. But if you don't want to use some shared modules from a lib plugin but just want to use the modules under your own plugin project, you can config the `muse.customLibs` section in `package.json`:

```js
"muse": {

  "customLibs": ["some-package"]
}
```

Every package in `customLibs` will not be from the shared modules. This usually happens when you want a different version of some modules.

## Summary
Shared modules is a core mechanism for Muse. The biggest difference is there's no async shared modules. So it's important to plan which modules should be shared. And, be careful to remove shared modules from a lib plugin since maybe some plugin already use it.
