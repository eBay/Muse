# Plugin Types and Bootstrap

In this topic we will learn more details about plugin types and the Muse app bootstrap flow.

## Plugin types

Every Muse plugin is a normal js bundle loaded via a `<script>` tag in the page. There are 4 types: `boot`, `init`, `lib` and `normal` which have different purposes:

- **boot plugin**: there is only one `boot` plugin on each app. Though we call it a "plugin" actually it's just a normal javascript code used to do some initialization of Muse app and load other plugins.
- **init plugin**: technically a `init` plugin is also normal javascript code same with `boot` plugin. It's used to do some custom initialization before starting the app. For example, check authentication, setup google analytics, etc. You can put all initialization logic in one `init` plugin or multiple ones.
- **normal plugin**: it's where you implement main business logics. We suggest we create one plugin for one feature, so normally you have multiple `normal` plugins.
- **lib plugin**: a `lib` plugin can also be used as `normal` plugin but it can provide shared modules at run time. By default, all modules used by a `lib` plugin are able to be shared to other plugins including other `lib` plugins.

Below picture shows the overview plugin Muse plugin types:

<img src={require("/img/plugin-types.png").default} width="500" />

When you open a Muse app, the `boot` plugin is first loaded, then it loads init plugins in parallel. After that, it loads `lib` and `normal` plugins in parallel.

At run time, `normal` and `lib` plugins can register plugin instance to the plugin engine (js-plugin). `lib` plugin provides shared modules.

:::note
`boot` and `init` plugins neither use shared modules nor plugin engine, they are just pure javascript bundles. So, they should usually have very few or no dependencies to be small.
:::note

## Bootstrap flow
Different types of plugins have different execution points as below picture shows:

<img src={require("/img/loading-flow-2.png").default} width="640" />

First, the `index.html` must have an embeded `<script>` tag to load the boot plugin, then the boot plugin starts the loading flow.

`init` plugins are executed while loaded. But `init` plugins could register executors which are executed after all `init` plugins are loaded. For example:

```js title="my-init-plugin/src/index.js"
MUSE_GLOBAL.initEntries.push({
  name: 'demo-init-plugin',
  func: () => {
    // do something after all init plugins are loaded.
  },
});
```

There is a special feature for `initEntries`, that is, if any init entry function returns `false`, then the whole starting flow is terminated. That is, all other plugins will not be loaded and executed. This is usually used to do authentication and redirect to the log in page.

Not every `init` plugin should register an init entry.


For `lib` and `normal` plugins, they are loaded in parallel but executed in order. That means, even such a plugin is loaded its code (src/index.js) is not executed. This is achieved by the Muse webpack plugin: when build a plugin, it actually wrap `src/index.js` in a function which is registered by:

```js title="auto generated by webpack plugin"
MUSE_GLOBAL.pluginEntries.push({
  id: 'users-plugin@0.1.0/src/index.js',
  func: () => {/* build result here */},
});
```

But during the code loading, all shared modules are registered in the shared modules container. So it's then safe to execute all plugin entries.

At last, the app execute the app entry:

- If not specified app entry and only one app entry registered, it's executed.
- If specifed app entry exists then excute it otherwise throws error.

## Summary
This is a short topic for you to understand Muse plugins concept and how a Muse app is started. It's helpful for you to under other parts of the documentation.